# Skill Update Backlog (1000 Updates)

This backlog lists 1000 new skill updates. Every update includes:
- Why the new skill is needed
- A step-by-step implementation guide

## Update 1: Epistemic Signal Ingestion Normalizer
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Signal Ingestion Normalizer`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 2: Epistemic Context Window Prioritizer
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Context Window Prioritizer`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 3: Epistemic Evidence Provenance Tracker
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Evidence Provenance Tracker`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 4: Epistemic Contradiction Detector
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Contradiction Detector`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 5: Epistemic Confidence Calibration Engine
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Confidence Calibration Engine`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 6: Epistemic Counterfactual Simulator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Counterfactual Simulator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 7: Epistemic Goal Decomposer
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Goal Decomposer`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 8: Epistemic Dependency DAG Planner
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Dependency DAG Planner`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 9: Epistemic Resource Budget Allocator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Resource Budget Allocator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 10: Epistemic Risk-Aware Scheduler
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Risk-Aware Scheduler`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 11: Epistemic Policy Constraint Compiler
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Policy Constraint Compiler`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 12: Epistemic Human Approval Router
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Human Approval Router`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 13: Epistemic Task Handoff Contractor
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Task Handoff Contractor`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 14: Epistemic Tool Health Monitor
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Tool Health Monitor`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 15: Epistemic Auto-Retry and Backoff Coordinator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 16: Epistemic Failure Root-Cause Miner
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Failure Root-Cause Miner`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 17: Epistemic Regression Sentinel
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Regression Sentinel`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 18: Epistemic Memory Consolidation Pipeline
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Memory Consolidation Pipeline`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 19: Epistemic Knowledge Graph Linker
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Knowledge Graph Linker`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 20: Epistemic Semantic Retrieval Ranker
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Semantic Retrieval Ranker`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 21: Epistemic Plan Quality Evaluator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Plan Quality Evaluator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 22: Epistemic Multi-Agent Negotiation Mediator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 23: Epistemic Conflict Resolution Coach
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Conflict Resolution Coach`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 24: Epistemic Explainability Narrative Builder
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Explainability Narrative Builder`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 25: Epistemic Uncertainty Communicator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Uncertainty Communicator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 26: Epistemic Experiment Design Generator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Experiment Design Generator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 27: Epistemic A/B Rollout Governor
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic A/B Rollout Governor`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 28: Epistemic Incident Playbook Synthesizer
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Incident Playbook Synthesizer`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 29: Epistemic Disaster Recovery Orchestrator
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 30: Epistemic Privacy Preserving Data Broker
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Privacy Preserving Data Broker`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 31: Epistemic Security Threat Modeler
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Security Threat Modeler`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 32: Epistemic Compliance Evidence Mapper
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Compliance Evidence Mapper`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 33: Epistemic Cost-Benefit Forecaster
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Cost-Benefit Forecaster`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 34: Epistemic Equity Impact Scorer
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Equity Impact Scorer`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 35: Epistemic Community Feedback Harvester
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Community Feedback Harvester`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 36: Epistemic KPI Dashboard Publisher
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic KPI Dashboard Publisher`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 37: Epistemic Skill Gap Diagnoser
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Skill Gap Diagnoser`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 38: Epistemic Training Curriculum Composer
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Training Curriculum Composer`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 39: Epistemic Self-Reflection Error Taxonomist
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 40: Epistemic Continuous Improvement Planner
- Domain: Truth-Seeking and Epistemics
- Why this new skill is needed: We need this skill because decisions drift when claims are accepted without verification. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Epistemic Continuous Improvement Planner`, including at least three measurable KPIs tied to false certainty and unverified assumptions.
2. Design and version the input/output contract for claims, evidence, and confidence traces, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover false certainty and unverified assumptions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 41: Planning Signal Ingestion Normalizer
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Signal Ingestion Normalizer`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 42: Planning Context Window Prioritizer
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Context Window Prioritizer`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 43: Planning Evidence Provenance Tracker
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Evidence Provenance Tracker`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 44: Planning Contradiction Detector
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Contradiction Detector`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 45: Planning Confidence Calibration Engine
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Confidence Calibration Engine`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 46: Planning Counterfactual Simulator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Counterfactual Simulator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 47: Planning Goal Decomposer
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Goal Decomposer`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 48: Planning Dependency DAG Planner
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Dependency DAG Planner`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 49: Planning Resource Budget Allocator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Resource Budget Allocator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 50: Planning Risk-Aware Scheduler
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Risk-Aware Scheduler`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 51: Planning Policy Constraint Compiler
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Policy Constraint Compiler`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 52: Planning Human Approval Router
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Human Approval Router`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 53: Planning Task Handoff Contractor
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Task Handoff Contractor`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 54: Planning Tool Health Monitor
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Tool Health Monitor`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 55: Planning Auto-Retry and Backoff Coordinator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 56: Planning Failure Root-Cause Miner
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Failure Root-Cause Miner`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 57: Planning Regression Sentinel
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Regression Sentinel`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 58: Planning Memory Consolidation Pipeline
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Memory Consolidation Pipeline`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 59: Planning Knowledge Graph Linker
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Knowledge Graph Linker`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 60: Planning Semantic Retrieval Ranker
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Semantic Retrieval Ranker`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 61: Planning Plan Quality Evaluator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Plan Quality Evaluator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 62: Planning Multi-Agent Negotiation Mediator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 63: Planning Conflict Resolution Coach
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Conflict Resolution Coach`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 64: Planning Explainability Narrative Builder
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Explainability Narrative Builder`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 65: Planning Uncertainty Communicator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Uncertainty Communicator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 66: Planning Experiment Design Generator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Experiment Design Generator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 67: Planning A/B Rollout Governor
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning A/B Rollout Governor`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 68: Planning Incident Playbook Synthesizer
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Incident Playbook Synthesizer`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 69: Planning Disaster Recovery Orchestrator
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 70: Planning Privacy Preserving Data Broker
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Privacy Preserving Data Broker`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 71: Planning Security Threat Modeler
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Security Threat Modeler`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 72: Planning Compliance Evidence Mapper
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Compliance Evidence Mapper`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 73: Planning Cost-Benefit Forecaster
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Cost-Benefit Forecaster`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 74: Planning Equity Impact Scorer
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Equity Impact Scorer`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 75: Planning Community Feedback Harvester
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Community Feedback Harvester`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 76: Planning KPI Dashboard Publisher
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning KPI Dashboard Publisher`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 77: Planning Skill Gap Diagnoser
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Skill Gap Diagnoser`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 78: Planning Training Curriculum Composer
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Training Curriculum Composer`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 79: Planning Self-Reflection Error Taxonomist
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 80: Planning Continuous Improvement Planner
- Domain: Strategic Planning and Decomposition
- Why this new skill is needed: We need this skill because large goals fail when decomposition is inconsistent or incomplete. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Planning Continuous Improvement Planner`, including at least three measurable KPIs tied to execution stalls and hidden dependency failures.
2. Design and version the input/output contract for goals, dependencies, milestones, and constraints, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover execution stalls and hidden dependency failures, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 81: Memory Signal Ingestion Normalizer
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Signal Ingestion Normalizer`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 82: Memory Context Window Prioritizer
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Context Window Prioritizer`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 83: Memory Evidence Provenance Tracker
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Evidence Provenance Tracker`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 84: Memory Contradiction Detector
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Contradiction Detector`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 85: Memory Confidence Calibration Engine
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Confidence Calibration Engine`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 86: Memory Counterfactual Simulator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Counterfactual Simulator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 87: Memory Goal Decomposer
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Goal Decomposer`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 88: Memory Dependency DAG Planner
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Dependency DAG Planner`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 89: Memory Resource Budget Allocator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Resource Budget Allocator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 90: Memory Risk-Aware Scheduler
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Risk-Aware Scheduler`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 91: Memory Policy Constraint Compiler
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Policy Constraint Compiler`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 92: Memory Human Approval Router
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Human Approval Router`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 93: Memory Task Handoff Contractor
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Task Handoff Contractor`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 94: Memory Tool Health Monitor
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Tool Health Monitor`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 95: Memory Auto-Retry and Backoff Coordinator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 96: Memory Failure Root-Cause Miner
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Failure Root-Cause Miner`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 97: Memory Regression Sentinel
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Regression Sentinel`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 98: Memory Memory Consolidation Pipeline
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Memory Consolidation Pipeline`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 99: Memory Knowledge Graph Linker
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Knowledge Graph Linker`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 100: Memory Semantic Retrieval Ranker
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Semantic Retrieval Ranker`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 101: Memory Plan Quality Evaluator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Plan Quality Evaluator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 102: Memory Multi-Agent Negotiation Mediator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 103: Memory Conflict Resolution Coach
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Conflict Resolution Coach`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 104: Memory Explainability Narrative Builder
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Explainability Narrative Builder`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 105: Memory Uncertainty Communicator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Uncertainty Communicator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 106: Memory Experiment Design Generator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Experiment Design Generator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 107: Memory A/B Rollout Governor
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory A/B Rollout Governor`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 108: Memory Incident Playbook Synthesizer
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Incident Playbook Synthesizer`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 109: Memory Disaster Recovery Orchestrator
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 110: Memory Privacy Preserving Data Broker
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Privacy Preserving Data Broker`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 111: Memory Security Threat Modeler
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Security Threat Modeler`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 112: Memory Compliance Evidence Mapper
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Compliance Evidence Mapper`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 113: Memory Cost-Benefit Forecaster
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Cost-Benefit Forecaster`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 114: Memory Equity Impact Scorer
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Equity Impact Scorer`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 115: Memory Community Feedback Harvester
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Community Feedback Harvester`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 116: Memory KPI Dashboard Publisher
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory KPI Dashboard Publisher`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 117: Memory Skill Gap Diagnoser
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Skill Gap Diagnoser`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 118: Memory Training Curriculum Composer
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Training Curriculum Composer`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 119: Memory Self-Reflection Error Taxonomist
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 120: Memory Continuous Improvement Planner
- Domain: Memory and Knowledge Operations
- Why this new skill is needed: We need this skill because agents lose performance when lessons are not retained and reused. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Memory Continuous Improvement Planner`, including at least three measurable KPIs tied to repeated mistakes and context loss.
2. Design and version the input/output contract for episodic logs, knowledge nodes, and retrieval metadata, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover repeated mistakes and context loss, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 121: Tooling Signal Ingestion Normalizer
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Signal Ingestion Normalizer`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 122: Tooling Context Window Prioritizer
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Context Window Prioritizer`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 123: Tooling Evidence Provenance Tracker
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Evidence Provenance Tracker`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 124: Tooling Contradiction Detector
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Contradiction Detector`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 125: Tooling Confidence Calibration Engine
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Confidence Calibration Engine`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 126: Tooling Counterfactual Simulator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Counterfactual Simulator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 127: Tooling Goal Decomposer
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Goal Decomposer`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 128: Tooling Dependency DAG Planner
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Dependency DAG Planner`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 129: Tooling Resource Budget Allocator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Resource Budget Allocator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 130: Tooling Risk-Aware Scheduler
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Risk-Aware Scheduler`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 131: Tooling Policy Constraint Compiler
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Policy Constraint Compiler`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 132: Tooling Human Approval Router
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Human Approval Router`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 133: Tooling Task Handoff Contractor
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Task Handoff Contractor`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 134: Tooling Tool Health Monitor
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Tool Health Monitor`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 135: Tooling Auto-Retry and Backoff Coordinator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 136: Tooling Failure Root-Cause Miner
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Failure Root-Cause Miner`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 137: Tooling Regression Sentinel
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Regression Sentinel`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 138: Tooling Memory Consolidation Pipeline
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Memory Consolidation Pipeline`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 139: Tooling Knowledge Graph Linker
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Knowledge Graph Linker`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 140: Tooling Semantic Retrieval Ranker
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Semantic Retrieval Ranker`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 141: Tooling Plan Quality Evaluator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Plan Quality Evaluator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 142: Tooling Multi-Agent Negotiation Mediator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 143: Tooling Conflict Resolution Coach
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Conflict Resolution Coach`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 144: Tooling Explainability Narrative Builder
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Explainability Narrative Builder`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 145: Tooling Uncertainty Communicator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Uncertainty Communicator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 146: Tooling Experiment Design Generator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Experiment Design Generator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 147: Tooling A/B Rollout Governor
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling A/B Rollout Governor`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 148: Tooling Incident Playbook Synthesizer
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Incident Playbook Synthesizer`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 149: Tooling Disaster Recovery Orchestrator
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 150: Tooling Privacy Preserving Data Broker
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Privacy Preserving Data Broker`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 151: Tooling Security Threat Modeler
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Security Threat Modeler`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 152: Tooling Compliance Evidence Mapper
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Compliance Evidence Mapper`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 153: Tooling Cost-Benefit Forecaster
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Cost-Benefit Forecaster`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 154: Tooling Equity Impact Scorer
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Equity Impact Scorer`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 155: Tooling Community Feedback Harvester
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Community Feedback Harvester`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 156: Tooling KPI Dashboard Publisher
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling KPI Dashboard Publisher`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 157: Tooling Skill Gap Diagnoser
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Skill Gap Diagnoser`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 158: Tooling Training Curriculum Composer
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Training Curriculum Composer`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 159: Tooling Self-Reflection Error Taxonomist
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 160: Tooling Continuous Improvement Planner
- Domain: Tool Reliability and Execution Quality
- Why this new skill is needed: We need this skill because automation collapses when tools are flaky and failure modes are opaque. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Tooling Continuous Improvement Planner`, including at least three measurable KPIs tied to silent failures and cascading retries.
2. Design and version the input/output contract for tool runs, error signatures, and retry outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover silent failures and cascading retries, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 161: Governance Signal Ingestion Normalizer
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Signal Ingestion Normalizer`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 162: Governance Context Window Prioritizer
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Context Window Prioritizer`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 163: Governance Evidence Provenance Tracker
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Evidence Provenance Tracker`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 164: Governance Contradiction Detector
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Contradiction Detector`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 165: Governance Confidence Calibration Engine
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Confidence Calibration Engine`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 166: Governance Counterfactual Simulator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Counterfactual Simulator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 167: Governance Goal Decomposer
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Goal Decomposer`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 168: Governance Dependency DAG Planner
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Dependency DAG Planner`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 169: Governance Resource Budget Allocator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Resource Budget Allocator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 170: Governance Risk-Aware Scheduler
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Risk-Aware Scheduler`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 171: Governance Policy Constraint Compiler
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Policy Constraint Compiler`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 172: Governance Human Approval Router
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Human Approval Router`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 173: Governance Task Handoff Contractor
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Task Handoff Contractor`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 174: Governance Tool Health Monitor
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Tool Health Monitor`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 175: Governance Auto-Retry and Backoff Coordinator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 176: Governance Failure Root-Cause Miner
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Failure Root-Cause Miner`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 177: Governance Regression Sentinel
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Regression Sentinel`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 178: Governance Memory Consolidation Pipeline
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Memory Consolidation Pipeline`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 179: Governance Knowledge Graph Linker
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Knowledge Graph Linker`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 180: Governance Semantic Retrieval Ranker
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Semantic Retrieval Ranker`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 181: Governance Plan Quality Evaluator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Plan Quality Evaluator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 182: Governance Multi-Agent Negotiation Mediator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 183: Governance Conflict Resolution Coach
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Conflict Resolution Coach`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 184: Governance Explainability Narrative Builder
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Explainability Narrative Builder`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 185: Governance Uncertainty Communicator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Uncertainty Communicator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 186: Governance Experiment Design Generator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Experiment Design Generator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 187: Governance A/B Rollout Governor
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance A/B Rollout Governor`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 188: Governance Incident Playbook Synthesizer
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Incident Playbook Synthesizer`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 189: Governance Disaster Recovery Orchestrator
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 190: Governance Privacy Preserving Data Broker
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Privacy Preserving Data Broker`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 191: Governance Security Threat Modeler
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Security Threat Modeler`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 192: Governance Compliance Evidence Mapper
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Compliance Evidence Mapper`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 193: Governance Cost-Benefit Forecaster
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Cost-Benefit Forecaster`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 194: Governance Equity Impact Scorer
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Equity Impact Scorer`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 195: Governance Community Feedback Harvester
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Community Feedback Harvester`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 196: Governance KPI Dashboard Publisher
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance KPI Dashboard Publisher`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 197: Governance Skill Gap Diagnoser
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Skill Gap Diagnoser`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 198: Governance Training Curriculum Composer
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Training Curriculum Composer`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 199: Governance Self-Reflection Error Taxonomist
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 200: Governance Continuous Improvement Planner
- Domain: Safety and Governance
- Why this new skill is needed: We need this skill because high-speed autonomy needs enforceable guardrails to stay aligned. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Governance Continuous Improvement Planner`, including at least three measurable KPIs tied to unsafe actions and policy drift.
2. Design and version the input/output contract for policies, violations, and mitigation actions, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover unsafe actions and policy drift, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 201: Oversight Signal Ingestion Normalizer
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Signal Ingestion Normalizer`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 202: Oversight Context Window Prioritizer
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Context Window Prioritizer`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 203: Oversight Evidence Provenance Tracker
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Evidence Provenance Tracker`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 204: Oversight Contradiction Detector
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Contradiction Detector`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 205: Oversight Confidence Calibration Engine
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Confidence Calibration Engine`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 206: Oversight Counterfactual Simulator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Counterfactual Simulator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 207: Oversight Goal Decomposer
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Goal Decomposer`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 208: Oversight Dependency DAG Planner
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Dependency DAG Planner`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 209: Oversight Resource Budget Allocator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Resource Budget Allocator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 210: Oversight Risk-Aware Scheduler
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Risk-Aware Scheduler`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 211: Oversight Policy Constraint Compiler
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Policy Constraint Compiler`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 212: Oversight Human Approval Router
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Human Approval Router`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 213: Oversight Task Handoff Contractor
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Task Handoff Contractor`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 214: Oversight Tool Health Monitor
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Tool Health Monitor`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 215: Oversight Auto-Retry and Backoff Coordinator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 216: Oversight Failure Root-Cause Miner
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Failure Root-Cause Miner`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 217: Oversight Regression Sentinel
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Regression Sentinel`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 218: Oversight Memory Consolidation Pipeline
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Memory Consolidation Pipeline`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 219: Oversight Knowledge Graph Linker
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Knowledge Graph Linker`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 220: Oversight Semantic Retrieval Ranker
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Semantic Retrieval Ranker`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 221: Oversight Plan Quality Evaluator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Plan Quality Evaluator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 222: Oversight Multi-Agent Negotiation Mediator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 223: Oversight Conflict Resolution Coach
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Conflict Resolution Coach`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 224: Oversight Explainability Narrative Builder
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Explainability Narrative Builder`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 225: Oversight Uncertainty Communicator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Uncertainty Communicator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 226: Oversight Experiment Design Generator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Experiment Design Generator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 227: Oversight A/B Rollout Governor
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight A/B Rollout Governor`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 228: Oversight Incident Playbook Synthesizer
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Incident Playbook Synthesizer`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 229: Oversight Disaster Recovery Orchestrator
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 230: Oversight Privacy Preserving Data Broker
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Privacy Preserving Data Broker`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 231: Oversight Security Threat Modeler
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Security Threat Modeler`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 232: Oversight Compliance Evidence Mapper
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Compliance Evidence Mapper`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 233: Oversight Cost-Benefit Forecaster
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Cost-Benefit Forecaster`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 234: Oversight Equity Impact Scorer
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Equity Impact Scorer`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 235: Oversight Community Feedback Harvester
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Community Feedback Harvester`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 236: Oversight KPI Dashboard Publisher
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight KPI Dashboard Publisher`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 237: Oversight Skill Gap Diagnoser
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Skill Gap Diagnoser`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 238: Oversight Training Curriculum Composer
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Training Curriculum Composer`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 239: Oversight Self-Reflection Error Taxonomist
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 240: Oversight Continuous Improvement Planner
- Domain: Human Oversight and Operator UX
- Why this new skill is needed: We need this skill because human teams need fast, legible control when stakes are high. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Oversight Continuous Improvement Planner`, including at least three measurable KPIs tied to slow interventions and approval bottlenecks.
2. Design and version the input/output contract for approval queues, operator workload, and intervention history, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow interventions and approval bottlenecks, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 241: Collab Signal Ingestion Normalizer
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Signal Ingestion Normalizer`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 242: Collab Context Window Prioritizer
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Context Window Prioritizer`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 243: Collab Evidence Provenance Tracker
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Evidence Provenance Tracker`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 244: Collab Contradiction Detector
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Contradiction Detector`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 245: Collab Confidence Calibration Engine
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Confidence Calibration Engine`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 246: Collab Counterfactual Simulator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Counterfactual Simulator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 247: Collab Goal Decomposer
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Goal Decomposer`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 248: Collab Dependency DAG Planner
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Dependency DAG Planner`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 249: Collab Resource Budget Allocator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Resource Budget Allocator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 250: Collab Risk-Aware Scheduler
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Risk-Aware Scheduler`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 251: Collab Policy Constraint Compiler
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Policy Constraint Compiler`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 252: Collab Human Approval Router
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Human Approval Router`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 253: Collab Task Handoff Contractor
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Task Handoff Contractor`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 254: Collab Tool Health Monitor
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Tool Health Monitor`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 255: Collab Auto-Retry and Backoff Coordinator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 256: Collab Failure Root-Cause Miner
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Failure Root-Cause Miner`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 257: Collab Regression Sentinel
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Regression Sentinel`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 258: Collab Memory Consolidation Pipeline
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Memory Consolidation Pipeline`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 259: Collab Knowledge Graph Linker
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Knowledge Graph Linker`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 260: Collab Semantic Retrieval Ranker
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Semantic Retrieval Ranker`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 261: Collab Plan Quality Evaluator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Plan Quality Evaluator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 262: Collab Multi-Agent Negotiation Mediator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 263: Collab Conflict Resolution Coach
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Conflict Resolution Coach`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 264: Collab Explainability Narrative Builder
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Explainability Narrative Builder`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 265: Collab Uncertainty Communicator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Uncertainty Communicator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 266: Collab Experiment Design Generator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Experiment Design Generator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 267: Collab A/B Rollout Governor
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab A/B Rollout Governor`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 268: Collab Incident Playbook Synthesizer
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Incident Playbook Synthesizer`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 269: Collab Disaster Recovery Orchestrator
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 270: Collab Privacy Preserving Data Broker
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Privacy Preserving Data Broker`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 271: Collab Security Threat Modeler
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Security Threat Modeler`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 272: Collab Compliance Evidence Mapper
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Compliance Evidence Mapper`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 273: Collab Cost-Benefit Forecaster
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Cost-Benefit Forecaster`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 274: Collab Equity Impact Scorer
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Equity Impact Scorer`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 275: Collab Community Feedback Harvester
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Community Feedback Harvester`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 276: Collab KPI Dashboard Publisher
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab KPI Dashboard Publisher`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 277: Collab Skill Gap Diagnoser
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Skill Gap Diagnoser`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 278: Collab Training Curriculum Composer
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Training Curriculum Composer`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 279: Collab Self-Reflection Error Taxonomist
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 280: Collab Continuous Improvement Planner
- Domain: Collaboration and Negotiation
- Why this new skill is needed: We need this skill because multi-agent systems underperform without explicit conflict resolution. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Collab Continuous Improvement Planner`, including at least three measurable KPIs tied to deadlocks and degraded trust.
2. Design and version the input/output contract for proposals, contention signals, and negotiated outcomes, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover deadlocks and degraded trust, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 281: Federation Signal Ingestion Normalizer
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Signal Ingestion Normalizer`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 282: Federation Context Window Prioritizer
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Context Window Prioritizer`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 283: Federation Evidence Provenance Tracker
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Evidence Provenance Tracker`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 284: Federation Contradiction Detector
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Contradiction Detector`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 285: Federation Confidence Calibration Engine
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Confidence Calibration Engine`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 286: Federation Counterfactual Simulator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Counterfactual Simulator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 287: Federation Goal Decomposer
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Goal Decomposer`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 288: Federation Dependency DAG Planner
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Dependency DAG Planner`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 289: Federation Resource Budget Allocator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Resource Budget Allocator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 290: Federation Risk-Aware Scheduler
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Risk-Aware Scheduler`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 291: Federation Policy Constraint Compiler
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Policy Constraint Compiler`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 292: Federation Human Approval Router
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Human Approval Router`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 293: Federation Task Handoff Contractor
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Task Handoff Contractor`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 294: Federation Tool Health Monitor
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Tool Health Monitor`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 295: Federation Auto-Retry and Backoff Coordinator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 296: Federation Failure Root-Cause Miner
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Failure Root-Cause Miner`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 297: Federation Regression Sentinel
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Regression Sentinel`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 298: Federation Memory Consolidation Pipeline
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Memory Consolidation Pipeline`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 299: Federation Knowledge Graph Linker
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Knowledge Graph Linker`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 300: Federation Semantic Retrieval Ranker
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Semantic Retrieval Ranker`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 301: Federation Plan Quality Evaluator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Plan Quality Evaluator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 302: Federation Multi-Agent Negotiation Mediator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 303: Federation Conflict Resolution Coach
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Conflict Resolution Coach`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 304: Federation Explainability Narrative Builder
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Explainability Narrative Builder`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 305: Federation Uncertainty Communicator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Uncertainty Communicator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 306: Federation Experiment Design Generator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Experiment Design Generator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 307: Federation A/B Rollout Governor
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation A/B Rollout Governor`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 308: Federation Incident Playbook Synthesizer
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Incident Playbook Synthesizer`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 309: Federation Disaster Recovery Orchestrator
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 310: Federation Privacy Preserving Data Broker
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Privacy Preserving Data Broker`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 311: Federation Security Threat Modeler
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Security Threat Modeler`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 312: Federation Compliance Evidence Mapper
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Compliance Evidence Mapper`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 313: Federation Cost-Benefit Forecaster
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Cost-Benefit Forecaster`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 314: Federation Equity Impact Scorer
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Equity Impact Scorer`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 315: Federation Community Feedback Harvester
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Community Feedback Harvester`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 316: Federation KPI Dashboard Publisher
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation KPI Dashboard Publisher`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 317: Federation Skill Gap Diagnoser
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Skill Gap Diagnoser`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 318: Federation Training Curriculum Composer
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Training Curriculum Composer`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 319: Federation Self-Reflection Error Taxonomist
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 320: Federation Continuous Improvement Planner
- Domain: Federation and Interoperability
- Why this new skill is needed: We need this skill because cross-org collaboration fails without shared contracts and trust primitives. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Federation Continuous Improvement Planner`, including at least three measurable KPIs tied to integration breakage and trust boundary violations.
2. Design and version the input/output contract for envelopes, tenant boundaries, and protocol bridges, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover integration breakage and trust boundary violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 321: Economic Signal Ingestion Normalizer
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Signal Ingestion Normalizer`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 322: Economic Context Window Prioritizer
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Context Window Prioritizer`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 323: Economic Evidence Provenance Tracker
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Evidence Provenance Tracker`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 324: Economic Contradiction Detector
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Contradiction Detector`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 325: Economic Confidence Calibration Engine
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Confidence Calibration Engine`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 326: Economic Counterfactual Simulator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Counterfactual Simulator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 327: Economic Goal Decomposer
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Goal Decomposer`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 328: Economic Dependency DAG Planner
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Dependency DAG Planner`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 329: Economic Resource Budget Allocator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Resource Budget Allocator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 330: Economic Risk-Aware Scheduler
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Risk-Aware Scheduler`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 331: Economic Policy Constraint Compiler
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Policy Constraint Compiler`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 332: Economic Human Approval Router
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Human Approval Router`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 333: Economic Task Handoff Contractor
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Task Handoff Contractor`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 334: Economic Tool Health Monitor
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Tool Health Monitor`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 335: Economic Auto-Retry and Backoff Coordinator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 336: Economic Failure Root-Cause Miner
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Failure Root-Cause Miner`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 337: Economic Regression Sentinel
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Regression Sentinel`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 338: Economic Memory Consolidation Pipeline
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Memory Consolidation Pipeline`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 339: Economic Knowledge Graph Linker
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Knowledge Graph Linker`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 340: Economic Semantic Retrieval Ranker
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Semantic Retrieval Ranker`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 341: Economic Plan Quality Evaluator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Plan Quality Evaluator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 342: Economic Multi-Agent Negotiation Mediator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 343: Economic Conflict Resolution Coach
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Conflict Resolution Coach`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 344: Economic Explainability Narrative Builder
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Explainability Narrative Builder`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 345: Economic Uncertainty Communicator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Uncertainty Communicator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 346: Economic Experiment Design Generator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Experiment Design Generator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 347: Economic A/B Rollout Governor
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic A/B Rollout Governor`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 348: Economic Incident Playbook Synthesizer
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Incident Playbook Synthesizer`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 349: Economic Disaster Recovery Orchestrator
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 350: Economic Privacy Preserving Data Broker
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Privacy Preserving Data Broker`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 351: Economic Security Threat Modeler
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Security Threat Modeler`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 352: Economic Compliance Evidence Mapper
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Compliance Evidence Mapper`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 353: Economic Cost-Benefit Forecaster
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Cost-Benefit Forecaster`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 354: Economic Equity Impact Scorer
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Equity Impact Scorer`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 355: Economic Community Feedback Harvester
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Community Feedback Harvester`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 356: Economic KPI Dashboard Publisher
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic KPI Dashboard Publisher`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 357: Economic Skill Gap Diagnoser
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Skill Gap Diagnoser`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 358: Economic Training Curriculum Composer
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Training Curriculum Composer`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 359: Economic Self-Reflection Error Taxonomist
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 360: Economic Continuous Improvement Planner
- Domain: Economic Optimization
- Why this new skill is needed: We need this skill because missions need explicit tradeoff logic for cost, speed, and impact. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Economic Continuous Improvement Planner`, including at least three measurable KPIs tied to overspending and low-impact allocation.
2. Design and version the input/output contract for budgets, costs, benefits, and opportunity values, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover overspending and low-impact allocation, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 361: Logistics Signal Ingestion Normalizer
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Signal Ingestion Normalizer`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 362: Logistics Context Window Prioritizer
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Context Window Prioritizer`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 363: Logistics Evidence Provenance Tracker
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Evidence Provenance Tracker`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 364: Logistics Contradiction Detector
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Contradiction Detector`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 365: Logistics Confidence Calibration Engine
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Confidence Calibration Engine`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 366: Logistics Counterfactual Simulator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Counterfactual Simulator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 367: Logistics Goal Decomposer
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Goal Decomposer`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 368: Logistics Dependency DAG Planner
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Dependency DAG Planner`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 369: Logistics Resource Budget Allocator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Resource Budget Allocator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 370: Logistics Risk-Aware Scheduler
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Risk-Aware Scheduler`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 371: Logistics Policy Constraint Compiler
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Policy Constraint Compiler`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 372: Logistics Human Approval Router
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Human Approval Router`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 373: Logistics Task Handoff Contractor
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Task Handoff Contractor`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 374: Logistics Tool Health Monitor
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Tool Health Monitor`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 375: Logistics Auto-Retry and Backoff Coordinator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 376: Logistics Failure Root-Cause Miner
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Failure Root-Cause Miner`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 377: Logistics Regression Sentinel
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Regression Sentinel`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 378: Logistics Memory Consolidation Pipeline
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Memory Consolidation Pipeline`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 379: Logistics Knowledge Graph Linker
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Knowledge Graph Linker`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 380: Logistics Semantic Retrieval Ranker
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Semantic Retrieval Ranker`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 381: Logistics Plan Quality Evaluator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Plan Quality Evaluator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 382: Logistics Multi-Agent Negotiation Mediator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 383: Logistics Conflict Resolution Coach
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Conflict Resolution Coach`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 384: Logistics Explainability Narrative Builder
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Explainability Narrative Builder`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 385: Logistics Uncertainty Communicator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Uncertainty Communicator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 386: Logistics Experiment Design Generator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Experiment Design Generator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 387: Logistics A/B Rollout Governor
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics A/B Rollout Governor`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 388: Logistics Incident Playbook Synthesizer
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Incident Playbook Synthesizer`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 389: Logistics Disaster Recovery Orchestrator
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 390: Logistics Privacy Preserving Data Broker
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Privacy Preserving Data Broker`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 391: Logistics Security Threat Modeler
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Security Threat Modeler`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 392: Logistics Compliance Evidence Mapper
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Compliance Evidence Mapper`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 393: Logistics Cost-Benefit Forecaster
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Cost-Benefit Forecaster`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 394: Logistics Equity Impact Scorer
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Equity Impact Scorer`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 395: Logistics Community Feedback Harvester
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Community Feedback Harvester`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 396: Logistics KPI Dashboard Publisher
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics KPI Dashboard Publisher`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 397: Logistics Skill Gap Diagnoser
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Skill Gap Diagnoser`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 398: Logistics Training Curriculum Composer
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Training Curriculum Composer`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 399: Logistics Self-Reflection Error Taxonomist
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 400: Logistics Continuous Improvement Planner
- Domain: Resource Allocation and Logistics
- Why this new skill is needed: We need this skill because impact work fails when scarce resources are not routed intelligently. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Logistics Continuous Improvement Planner`, including at least three measurable KPIs tied to supply shortfalls and fairness gaps.
2. Design and version the input/output contract for capacity, bottlenecks, and distribution plans, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover supply shortfalls and fairness gaps, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 401: PublicService Signal Ingestion Normalizer
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Signal Ingestion Normalizer`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 402: PublicService Context Window Prioritizer
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Context Window Prioritizer`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 403: PublicService Evidence Provenance Tracker
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Evidence Provenance Tracker`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 404: PublicService Contradiction Detector
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Contradiction Detector`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 405: PublicService Confidence Calibration Engine
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Confidence Calibration Engine`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 406: PublicService Counterfactual Simulator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Counterfactual Simulator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 407: PublicService Goal Decomposer
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Goal Decomposer`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 408: PublicService Dependency DAG Planner
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Dependency DAG Planner`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 409: PublicService Resource Budget Allocator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Resource Budget Allocator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 410: PublicService Risk-Aware Scheduler
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Risk-Aware Scheduler`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 411: PublicService Policy Constraint Compiler
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Policy Constraint Compiler`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 412: PublicService Human Approval Router
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Human Approval Router`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 413: PublicService Task Handoff Contractor
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Task Handoff Contractor`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 414: PublicService Tool Health Monitor
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Tool Health Monitor`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 415: PublicService Auto-Retry and Backoff Coordinator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 416: PublicService Failure Root-Cause Miner
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Failure Root-Cause Miner`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 417: PublicService Regression Sentinel
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Regression Sentinel`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 418: PublicService Memory Consolidation Pipeline
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Memory Consolidation Pipeline`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 419: PublicService Knowledge Graph Linker
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Knowledge Graph Linker`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 420: PublicService Semantic Retrieval Ranker
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Semantic Retrieval Ranker`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 421: PublicService Plan Quality Evaluator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Plan Quality Evaluator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 422: PublicService Multi-Agent Negotiation Mediator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 423: PublicService Conflict Resolution Coach
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Conflict Resolution Coach`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 424: PublicService Explainability Narrative Builder
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Explainability Narrative Builder`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 425: PublicService Uncertainty Communicator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Uncertainty Communicator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 426: PublicService Experiment Design Generator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Experiment Design Generator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 427: PublicService A/B Rollout Governor
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService A/B Rollout Governor`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 428: PublicService Incident Playbook Synthesizer
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Incident Playbook Synthesizer`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 429: PublicService Disaster Recovery Orchestrator
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 430: PublicService Privacy Preserving Data Broker
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Privacy Preserving Data Broker`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 431: PublicService Security Threat Modeler
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Security Threat Modeler`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 432: PublicService Compliance Evidence Mapper
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Compliance Evidence Mapper`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 433: PublicService Cost-Benefit Forecaster
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Cost-Benefit Forecaster`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 434: PublicService Equity Impact Scorer
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Equity Impact Scorer`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 435: PublicService Community Feedback Harvester
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Community Feedback Harvester`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 436: PublicService KPI Dashboard Publisher
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService KPI Dashboard Publisher`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 437: PublicService Skill Gap Diagnoser
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Skill Gap Diagnoser`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 438: PublicService Training Curriculum Composer
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Training Curriculum Composer`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 439: PublicService Self-Reflection Error Taxonomist
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 440: PublicService Continuous Improvement Planner
- Domain: Healthcare and Public Services
- Why this new skill is needed: We need this skill because public-facing workflows require strict safety and reliability controls. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `PublicService Continuous Improvement Planner`, including at least three measurable KPIs tied to service harm and procedural violations.
2. Design and version the input/output contract for protocol checks, service queues, and compliance flags, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover service harm and procedural violations, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 441: Education Signal Ingestion Normalizer
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Signal Ingestion Normalizer`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 442: Education Context Window Prioritizer
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Context Window Prioritizer`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 443: Education Evidence Provenance Tracker
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Evidence Provenance Tracker`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 444: Education Contradiction Detector
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Contradiction Detector`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 445: Education Confidence Calibration Engine
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Confidence Calibration Engine`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 446: Education Counterfactual Simulator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Counterfactual Simulator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 447: Education Goal Decomposer
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Goal Decomposer`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 448: Education Dependency DAG Planner
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Dependency DAG Planner`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 449: Education Resource Budget Allocator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Resource Budget Allocator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 450: Education Risk-Aware Scheduler
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Risk-Aware Scheduler`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 451: Education Policy Constraint Compiler
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Policy Constraint Compiler`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 452: Education Human Approval Router
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Human Approval Router`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 453: Education Task Handoff Contractor
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Task Handoff Contractor`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 454: Education Tool Health Monitor
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Tool Health Monitor`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 455: Education Auto-Retry and Backoff Coordinator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 456: Education Failure Root-Cause Miner
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Failure Root-Cause Miner`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 457: Education Regression Sentinel
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Regression Sentinel`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 458: Education Memory Consolidation Pipeline
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Memory Consolidation Pipeline`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 459: Education Knowledge Graph Linker
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Knowledge Graph Linker`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 460: Education Semantic Retrieval Ranker
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Semantic Retrieval Ranker`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 461: Education Plan Quality Evaluator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Plan Quality Evaluator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 462: Education Multi-Agent Negotiation Mediator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 463: Education Conflict Resolution Coach
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Conflict Resolution Coach`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 464: Education Explainability Narrative Builder
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Explainability Narrative Builder`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 465: Education Uncertainty Communicator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Uncertainty Communicator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 466: Education Experiment Design Generator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Experiment Design Generator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 467: Education A/B Rollout Governor
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education A/B Rollout Governor`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 468: Education Incident Playbook Synthesizer
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Incident Playbook Synthesizer`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 469: Education Disaster Recovery Orchestrator
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 470: Education Privacy Preserving Data Broker
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Privacy Preserving Data Broker`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 471: Education Security Threat Modeler
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Security Threat Modeler`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 472: Education Compliance Evidence Mapper
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Compliance Evidence Mapper`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 473: Education Cost-Benefit Forecaster
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Cost-Benefit Forecaster`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 474: Education Equity Impact Scorer
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Equity Impact Scorer`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 475: Education Community Feedback Harvester
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Community Feedback Harvester`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 476: Education KPI Dashboard Publisher
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education KPI Dashboard Publisher`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 477: Education Skill Gap Diagnoser
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Skill Gap Diagnoser`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 478: Education Training Curriculum Composer
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Training Curriculum Composer`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 479: Education Self-Reflection Error Taxonomist
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 480: Education Continuous Improvement Planner
- Domain: Education and Upskilling
- Why this new skill is needed: We need this skill because human capability growth requires targeted planning under constraints. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Education Continuous Improvement Planner`, including at least three measurable KPIs tied to persistent skill gaps and poor learning outcomes.
2. Design and version the input/output contract for skill profiles, learning paths, and support resources, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover persistent skill gaps and poor learning outcomes, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 481: Research Signal Ingestion Normalizer
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Signal Ingestion Normalizer`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 482: Research Context Window Prioritizer
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Context Window Prioritizer`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 483: Research Evidence Provenance Tracker
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Evidence Provenance Tracker`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 484: Research Contradiction Detector
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Contradiction Detector`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 485: Research Confidence Calibration Engine
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Confidence Calibration Engine`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 486: Research Counterfactual Simulator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Counterfactual Simulator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 487: Research Goal Decomposer
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Goal Decomposer`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 488: Research Dependency DAG Planner
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Dependency DAG Planner`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 489: Research Resource Budget Allocator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Resource Budget Allocator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 490: Research Risk-Aware Scheduler
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Risk-Aware Scheduler`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 491: Research Policy Constraint Compiler
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Policy Constraint Compiler`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 492: Research Human Approval Router
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Human Approval Router`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 493: Research Task Handoff Contractor
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Task Handoff Contractor`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 494: Research Tool Health Monitor
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Tool Health Monitor`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 495: Research Auto-Retry and Backoff Coordinator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 496: Research Failure Root-Cause Miner
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Failure Root-Cause Miner`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 497: Research Regression Sentinel
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Regression Sentinel`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 498: Research Memory Consolidation Pipeline
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Memory Consolidation Pipeline`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 499: Research Knowledge Graph Linker
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Knowledge Graph Linker`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 500: Research Semantic Retrieval Ranker
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Semantic Retrieval Ranker`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 501: Research Plan Quality Evaluator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Plan Quality Evaluator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 502: Research Multi-Agent Negotiation Mediator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 503: Research Conflict Resolution Coach
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Conflict Resolution Coach`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 504: Research Explainability Narrative Builder
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Explainability Narrative Builder`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 505: Research Uncertainty Communicator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Uncertainty Communicator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 506: Research Experiment Design Generator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Experiment Design Generator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 507: Research A/B Rollout Governor
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research A/B Rollout Governor`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 508: Research Incident Playbook Synthesizer
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Incident Playbook Synthesizer`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 509: Research Disaster Recovery Orchestrator
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 510: Research Privacy Preserving Data Broker
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Privacy Preserving Data Broker`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 511: Research Security Threat Modeler
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Security Threat Modeler`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 512: Research Compliance Evidence Mapper
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Compliance Evidence Mapper`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 513: Research Cost-Benefit Forecaster
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Cost-Benefit Forecaster`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 514: Research Equity Impact Scorer
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Equity Impact Scorer`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 515: Research Community Feedback Harvester
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Community Feedback Harvester`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 516: Research KPI Dashboard Publisher
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research KPI Dashboard Publisher`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 517: Research Skill Gap Diagnoser
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Skill Gap Diagnoser`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 518: Research Training Curriculum Composer
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Training Curriculum Composer`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 519: Research Self-Reflection Error Taxonomist
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 520: Research Continuous Improvement Planner
- Domain: Scientific Research Systems
- Why this new skill is needed: We need this skill because research throughput degrades without reproducibility and prioritization. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Research Continuous Improvement Planner`, including at least three measurable KPIs tied to non-reproducible results and wasted cycles.
2. Design and version the input/output contract for hypotheses, experiments, and replication evidence, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover non-reproducible results and wasted cycles, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 521: Engineering Signal Ingestion Normalizer
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Signal Ingestion Normalizer`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 522: Engineering Context Window Prioritizer
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Context Window Prioritizer`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 523: Engineering Evidence Provenance Tracker
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Evidence Provenance Tracker`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 524: Engineering Contradiction Detector
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Contradiction Detector`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 525: Engineering Confidence Calibration Engine
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Confidence Calibration Engine`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 526: Engineering Counterfactual Simulator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Counterfactual Simulator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 527: Engineering Goal Decomposer
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Goal Decomposer`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 528: Engineering Dependency DAG Planner
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Dependency DAG Planner`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 529: Engineering Resource Budget Allocator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Resource Budget Allocator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 530: Engineering Risk-Aware Scheduler
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Risk-Aware Scheduler`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 531: Engineering Policy Constraint Compiler
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Policy Constraint Compiler`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 532: Engineering Human Approval Router
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Human Approval Router`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 533: Engineering Task Handoff Contractor
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Task Handoff Contractor`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 534: Engineering Tool Health Monitor
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Tool Health Monitor`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 535: Engineering Auto-Retry and Backoff Coordinator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 536: Engineering Failure Root-Cause Miner
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Failure Root-Cause Miner`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 537: Engineering Regression Sentinel
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Regression Sentinel`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 538: Engineering Memory Consolidation Pipeline
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Memory Consolidation Pipeline`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 539: Engineering Knowledge Graph Linker
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Knowledge Graph Linker`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 540: Engineering Semantic Retrieval Ranker
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Semantic Retrieval Ranker`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 541: Engineering Plan Quality Evaluator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Plan Quality Evaluator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 542: Engineering Multi-Agent Negotiation Mediator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 543: Engineering Conflict Resolution Coach
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Conflict Resolution Coach`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 544: Engineering Explainability Narrative Builder
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Explainability Narrative Builder`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 545: Engineering Uncertainty Communicator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Uncertainty Communicator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 546: Engineering Experiment Design Generator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Experiment Design Generator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 547: Engineering A/B Rollout Governor
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering A/B Rollout Governor`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 548: Engineering Incident Playbook Synthesizer
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Incident Playbook Synthesizer`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 549: Engineering Disaster Recovery Orchestrator
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 550: Engineering Privacy Preserving Data Broker
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Privacy Preserving Data Broker`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 551: Engineering Security Threat Modeler
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Security Threat Modeler`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 552: Engineering Compliance Evidence Mapper
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Compliance Evidence Mapper`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 553: Engineering Cost-Benefit Forecaster
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Cost-Benefit Forecaster`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 554: Engineering Equity Impact Scorer
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Equity Impact Scorer`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 555: Engineering Community Feedback Harvester
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Community Feedback Harvester`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 556: Engineering KPI Dashboard Publisher
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering KPI Dashboard Publisher`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 557: Engineering Skill Gap Diagnoser
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Skill Gap Diagnoser`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 558: Engineering Training Curriculum Composer
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Training Curriculum Composer`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 559: Engineering Self-Reflection Error Taxonomist
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 560: Engineering Continuous Improvement Planner
- Domain: Software Engineering Automation
- Why this new skill is needed: We need this skill because delivery speed must increase without sacrificing correctness. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Engineering Continuous Improvement Planner`, including at least three measurable KPIs tied to regressions and brittle release pipelines.
2. Design and version the input/output contract for code changes, tests, incidents, and rollout data, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover regressions and brittle release pipelines, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 561: Observability Signal Ingestion Normalizer
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Signal Ingestion Normalizer`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 562: Observability Context Window Prioritizer
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Context Window Prioritizer`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 563: Observability Evidence Provenance Tracker
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Evidence Provenance Tracker`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 564: Observability Contradiction Detector
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Contradiction Detector`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 565: Observability Confidence Calibration Engine
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Confidence Calibration Engine`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 566: Observability Counterfactual Simulator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Counterfactual Simulator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 567: Observability Goal Decomposer
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Goal Decomposer`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 568: Observability Dependency DAG Planner
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Dependency DAG Planner`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 569: Observability Resource Budget Allocator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Resource Budget Allocator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 570: Observability Risk-Aware Scheduler
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Risk-Aware Scheduler`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 571: Observability Policy Constraint Compiler
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Policy Constraint Compiler`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 572: Observability Human Approval Router
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Human Approval Router`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 573: Observability Task Handoff Contractor
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Task Handoff Contractor`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 574: Observability Tool Health Monitor
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Tool Health Monitor`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 575: Observability Auto-Retry and Backoff Coordinator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 576: Observability Failure Root-Cause Miner
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Failure Root-Cause Miner`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 577: Observability Regression Sentinel
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Regression Sentinel`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 578: Observability Memory Consolidation Pipeline
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Memory Consolidation Pipeline`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 579: Observability Knowledge Graph Linker
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Knowledge Graph Linker`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 580: Observability Semantic Retrieval Ranker
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Semantic Retrieval Ranker`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 581: Observability Plan Quality Evaluator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Plan Quality Evaluator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 582: Observability Multi-Agent Negotiation Mediator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 583: Observability Conflict Resolution Coach
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Conflict Resolution Coach`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 584: Observability Explainability Narrative Builder
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Explainability Narrative Builder`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 585: Observability Uncertainty Communicator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Uncertainty Communicator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 586: Observability Experiment Design Generator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Experiment Design Generator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 587: Observability A/B Rollout Governor
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability A/B Rollout Governor`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 588: Observability Incident Playbook Synthesizer
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Incident Playbook Synthesizer`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 589: Observability Disaster Recovery Orchestrator
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 590: Observability Privacy Preserving Data Broker
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Privacy Preserving Data Broker`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 591: Observability Security Threat Modeler
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Security Threat Modeler`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 592: Observability Compliance Evidence Mapper
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Compliance Evidence Mapper`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 593: Observability Cost-Benefit Forecaster
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Cost-Benefit Forecaster`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 594: Observability Equity Impact Scorer
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Equity Impact Scorer`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 595: Observability Community Feedback Harvester
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Community Feedback Harvester`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 596: Observability KPI Dashboard Publisher
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability KPI Dashboard Publisher`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 597: Observability Skill Gap Diagnoser
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Skill Gap Diagnoser`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 598: Observability Training Curriculum Composer
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Training Curriculum Composer`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 599: Observability Self-Reflection Error Taxonomist
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 600: Observability Continuous Improvement Planner
- Domain: Data Quality and Observability
- Why this new skill is needed: We need this skill because decisions are only as good as the quality and visibility of data. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Observability Continuous Improvement Planner`, including at least three measurable KPIs tied to data drift and blind spots.
2. Design and version the input/output contract for freshness, drift, schema health, and telemetry coverage, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover data drift and blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 601: Security Signal Ingestion Normalizer
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Signal Ingestion Normalizer`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 602: Security Context Window Prioritizer
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Context Window Prioritizer`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 603: Security Evidence Provenance Tracker
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Evidence Provenance Tracker`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 604: Security Contradiction Detector
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Contradiction Detector`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 605: Security Confidence Calibration Engine
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Confidence Calibration Engine`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 606: Security Counterfactual Simulator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Counterfactual Simulator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 607: Security Goal Decomposer
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Goal Decomposer`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 608: Security Dependency DAG Planner
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Dependency DAG Planner`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 609: Security Resource Budget Allocator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Resource Budget Allocator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 610: Security Risk-Aware Scheduler
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Risk-Aware Scheduler`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 611: Security Policy Constraint Compiler
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Policy Constraint Compiler`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 612: Security Human Approval Router
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Human Approval Router`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 613: Security Task Handoff Contractor
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Task Handoff Contractor`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 614: Security Tool Health Monitor
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Tool Health Monitor`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 615: Security Auto-Retry and Backoff Coordinator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 616: Security Failure Root-Cause Miner
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Failure Root-Cause Miner`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 617: Security Regression Sentinel
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Regression Sentinel`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 618: Security Memory Consolidation Pipeline
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Memory Consolidation Pipeline`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 619: Security Knowledge Graph Linker
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Knowledge Graph Linker`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 620: Security Semantic Retrieval Ranker
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Semantic Retrieval Ranker`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 621: Security Plan Quality Evaluator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Plan Quality Evaluator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 622: Security Multi-Agent Negotiation Mediator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 623: Security Conflict Resolution Coach
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Conflict Resolution Coach`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 624: Security Explainability Narrative Builder
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Explainability Narrative Builder`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 625: Security Uncertainty Communicator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Uncertainty Communicator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 626: Security Experiment Design Generator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Experiment Design Generator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 627: Security A/B Rollout Governor
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security A/B Rollout Governor`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 628: Security Incident Playbook Synthesizer
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Incident Playbook Synthesizer`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 629: Security Disaster Recovery Orchestrator
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 630: Security Privacy Preserving Data Broker
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Privacy Preserving Data Broker`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 631: Security Security Threat Modeler
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Security Threat Modeler`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 632: Security Compliance Evidence Mapper
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Compliance Evidence Mapper`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 633: Security Cost-Benefit Forecaster
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Cost-Benefit Forecaster`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 634: Security Equity Impact Scorer
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Equity Impact Scorer`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 635: Security Community Feedback Harvester
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Community Feedback Harvester`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 636: Security KPI Dashboard Publisher
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security KPI Dashboard Publisher`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 637: Security Skill Gap Diagnoser
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Skill Gap Diagnoser`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 638: Security Training Curriculum Composer
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Training Curriculum Composer`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 639: Security Self-Reflection Error Taxonomist
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 640: Security Continuous Improvement Planner
- Domain: Security and Privacy
- Why this new skill is needed: We need this skill because production autonomy must default to least privilege and strong privacy. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Security Continuous Improvement Planner`, including at least three measurable KPIs tied to breach, exfiltration, and over-privileged actions.
2. Design and version the input/output contract for permissions, sensitive data flows, and threat events, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover breach, exfiltration, and over-privileged actions, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 641: Crisis Signal Ingestion Normalizer
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Signal Ingestion Normalizer`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 642: Crisis Context Window Prioritizer
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Context Window Prioritizer`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 643: Crisis Evidence Provenance Tracker
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Evidence Provenance Tracker`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 644: Crisis Contradiction Detector
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Contradiction Detector`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 645: Crisis Confidence Calibration Engine
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Confidence Calibration Engine`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 646: Crisis Counterfactual Simulator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Counterfactual Simulator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 647: Crisis Goal Decomposer
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Goal Decomposer`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 648: Crisis Dependency DAG Planner
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Dependency DAG Planner`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 649: Crisis Resource Budget Allocator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Resource Budget Allocator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 650: Crisis Risk-Aware Scheduler
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Risk-Aware Scheduler`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 651: Crisis Policy Constraint Compiler
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Policy Constraint Compiler`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 652: Crisis Human Approval Router
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Human Approval Router`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 653: Crisis Task Handoff Contractor
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Task Handoff Contractor`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 654: Crisis Tool Health Monitor
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Tool Health Monitor`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 655: Crisis Auto-Retry and Backoff Coordinator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 656: Crisis Failure Root-Cause Miner
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Failure Root-Cause Miner`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 657: Crisis Regression Sentinel
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Regression Sentinel`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 658: Crisis Memory Consolidation Pipeline
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Memory Consolidation Pipeline`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 659: Crisis Knowledge Graph Linker
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Knowledge Graph Linker`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 660: Crisis Semantic Retrieval Ranker
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Semantic Retrieval Ranker`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 661: Crisis Plan Quality Evaluator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Plan Quality Evaluator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 662: Crisis Multi-Agent Negotiation Mediator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 663: Crisis Conflict Resolution Coach
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Conflict Resolution Coach`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 664: Crisis Explainability Narrative Builder
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Explainability Narrative Builder`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 665: Crisis Uncertainty Communicator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Uncertainty Communicator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 666: Crisis Experiment Design Generator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Experiment Design Generator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 667: Crisis A/B Rollout Governor
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis A/B Rollout Governor`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 668: Crisis Incident Playbook Synthesizer
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Incident Playbook Synthesizer`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 669: Crisis Disaster Recovery Orchestrator
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 670: Crisis Privacy Preserving Data Broker
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Privacy Preserving Data Broker`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 671: Crisis Security Threat Modeler
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Security Threat Modeler`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 672: Crisis Compliance Evidence Mapper
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Compliance Evidence Mapper`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 673: Crisis Cost-Benefit Forecaster
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Cost-Benefit Forecaster`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 674: Crisis Equity Impact Scorer
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Equity Impact Scorer`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 675: Crisis Community Feedback Harvester
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Community Feedback Harvester`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 676: Crisis KPI Dashboard Publisher
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis KPI Dashboard Publisher`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 677: Crisis Skill Gap Diagnoser
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Skill Gap Diagnoser`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 678: Crisis Training Curriculum Composer
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Training Curriculum Composer`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 679: Crisis Self-Reflection Error Taxonomist
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 680: Crisis Continuous Improvement Planner
- Domain: Crisis and Incident Response
- Why this new skill is needed: We need this skill because response quality determines whether incidents are contained or amplified. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Crisis Continuous Improvement Planner`, including at least three measurable KPIs tied to slow containment and repeated outages.
2. Design and version the input/output contract for incident timelines, response roles, and recovery artifacts, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover slow containment and repeated outages, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 681: Impact Signal Ingestion Normalizer
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Signal Ingestion Normalizer`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 682: Impact Context Window Prioritizer
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Context Window Prioritizer`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 683: Impact Evidence Provenance Tracker
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Evidence Provenance Tracker`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 684: Impact Contradiction Detector
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Contradiction Detector`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 685: Impact Confidence Calibration Engine
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Confidence Calibration Engine`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 686: Impact Counterfactual Simulator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Counterfactual Simulator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 687: Impact Goal Decomposer
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Goal Decomposer`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 688: Impact Dependency DAG Planner
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Dependency DAG Planner`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 689: Impact Resource Budget Allocator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Resource Budget Allocator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 690: Impact Risk-Aware Scheduler
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Risk-Aware Scheduler`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 691: Impact Policy Constraint Compiler
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Policy Constraint Compiler`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 692: Impact Human Approval Router
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Human Approval Router`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 693: Impact Task Handoff Contractor
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Task Handoff Contractor`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 694: Impact Tool Health Monitor
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Tool Health Monitor`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 695: Impact Auto-Retry and Backoff Coordinator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 696: Impact Failure Root-Cause Miner
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Failure Root-Cause Miner`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 697: Impact Regression Sentinel
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Regression Sentinel`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 698: Impact Memory Consolidation Pipeline
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Memory Consolidation Pipeline`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 699: Impact Knowledge Graph Linker
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Knowledge Graph Linker`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 700: Impact Semantic Retrieval Ranker
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Semantic Retrieval Ranker`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 701: Impact Plan Quality Evaluator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Plan Quality Evaluator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 702: Impact Multi-Agent Negotiation Mediator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 703: Impact Conflict Resolution Coach
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Conflict Resolution Coach`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 704: Impact Explainability Narrative Builder
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Explainability Narrative Builder`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 705: Impact Uncertainty Communicator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Uncertainty Communicator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 706: Impact Experiment Design Generator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Experiment Design Generator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 707: Impact A/B Rollout Governor
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact A/B Rollout Governor`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 708: Impact Incident Playbook Synthesizer
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Incident Playbook Synthesizer`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 709: Impact Disaster Recovery Orchestrator
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 710: Impact Privacy Preserving Data Broker
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Privacy Preserving Data Broker`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 711: Impact Security Threat Modeler
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Security Threat Modeler`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 712: Impact Compliance Evidence Mapper
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Compliance Evidence Mapper`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 713: Impact Cost-Benefit Forecaster
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Cost-Benefit Forecaster`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 714: Impact Equity Impact Scorer
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Equity Impact Scorer`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 715: Impact Community Feedback Harvester
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Community Feedback Harvester`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 716: Impact KPI Dashboard Publisher
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact KPI Dashboard Publisher`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 717: Impact Skill Gap Diagnoser
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Skill Gap Diagnoser`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 718: Impact Training Curriculum Composer
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Training Curriculum Composer`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 719: Impact Self-Reflection Error Taxonomist
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 720: Impact Continuous Improvement Planner
- Domain: Social Impact Measurement
- Why this new skill is needed: We need this skill because missions need measurable outcomes, not just activity volume. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Impact Continuous Improvement Planner`, including at least three measurable KPIs tied to impact theater and unmeasured harm.
2. Design and version the input/output contract for community outcomes, KPI trends, and intervention deltas, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover impact theater and unmeasured harm, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 721: Comms Signal Ingestion Normalizer
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Signal Ingestion Normalizer`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 722: Comms Context Window Prioritizer
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Context Window Prioritizer`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 723: Comms Evidence Provenance Tracker
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Evidence Provenance Tracker`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 724: Comms Contradiction Detector
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Contradiction Detector`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 725: Comms Confidence Calibration Engine
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Confidence Calibration Engine`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 726: Comms Counterfactual Simulator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Counterfactual Simulator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 727: Comms Goal Decomposer
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Goal Decomposer`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 728: Comms Dependency DAG Planner
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Dependency DAG Planner`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 729: Comms Resource Budget Allocator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Resource Budget Allocator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 730: Comms Risk-Aware Scheduler
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Risk-Aware Scheduler`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 731: Comms Policy Constraint Compiler
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Policy Constraint Compiler`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 732: Comms Human Approval Router
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Human Approval Router`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 733: Comms Task Handoff Contractor
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Task Handoff Contractor`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 734: Comms Tool Health Monitor
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Tool Health Monitor`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 735: Comms Auto-Retry and Backoff Coordinator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 736: Comms Failure Root-Cause Miner
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Failure Root-Cause Miner`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 737: Comms Regression Sentinel
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Regression Sentinel`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 738: Comms Memory Consolidation Pipeline
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Memory Consolidation Pipeline`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 739: Comms Knowledge Graph Linker
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Knowledge Graph Linker`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 740: Comms Semantic Retrieval Ranker
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Semantic Retrieval Ranker`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 741: Comms Plan Quality Evaluator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Plan Quality Evaluator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 742: Comms Multi-Agent Negotiation Mediator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 743: Comms Conflict Resolution Coach
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Conflict Resolution Coach`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 744: Comms Explainability Narrative Builder
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Explainability Narrative Builder`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 745: Comms Uncertainty Communicator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Uncertainty Communicator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 746: Comms Experiment Design Generator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Experiment Design Generator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 747: Comms A/B Rollout Governor
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms A/B Rollout Governor`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 748: Comms Incident Playbook Synthesizer
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Incident Playbook Synthesizer`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 749: Comms Disaster Recovery Orchestrator
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 750: Comms Privacy Preserving Data Broker
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Privacy Preserving Data Broker`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 751: Comms Security Threat Modeler
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Security Threat Modeler`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 752: Comms Compliance Evidence Mapper
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Compliance Evidence Mapper`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 753: Comms Cost-Benefit Forecaster
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Cost-Benefit Forecaster`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 754: Comms Equity Impact Scorer
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Equity Impact Scorer`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 755: Comms Community Feedback Harvester
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Community Feedback Harvester`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 756: Comms KPI Dashboard Publisher
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms KPI Dashboard Publisher`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 757: Comms Skill Gap Diagnoser
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Skill Gap Diagnoser`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 758: Comms Training Curriculum Composer
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Training Curriculum Composer`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 759: Comms Self-Reflection Error Taxonomist
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 760: Comms Continuous Improvement Planner
- Domain: Communication and Explainability
- Why this new skill is needed: We need this skill because complex systems require explanations humans can act on quickly. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Comms Continuous Improvement Planner`, including at least three measurable KPIs tied to misinterpretation and trust erosion.
2. Design and version the input/output contract for decision factors, uncertainty markers, and audience summaries, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover misinterpretation and trust erosion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 761: Cultural Signal Ingestion Normalizer
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Signal Ingestion Normalizer`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 762: Cultural Context Window Prioritizer
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Context Window Prioritizer`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 763: Cultural Evidence Provenance Tracker
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Evidence Provenance Tracker`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 764: Cultural Contradiction Detector
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Contradiction Detector`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 765: Cultural Confidence Calibration Engine
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Confidence Calibration Engine`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 766: Cultural Counterfactual Simulator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Counterfactual Simulator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 767: Cultural Goal Decomposer
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Goal Decomposer`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 768: Cultural Dependency DAG Planner
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Dependency DAG Planner`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 769: Cultural Resource Budget Allocator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Resource Budget Allocator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 770: Cultural Risk-Aware Scheduler
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Risk-Aware Scheduler`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 771: Cultural Policy Constraint Compiler
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Policy Constraint Compiler`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 772: Cultural Human Approval Router
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Human Approval Router`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 773: Cultural Task Handoff Contractor
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Task Handoff Contractor`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 774: Cultural Tool Health Monitor
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Tool Health Monitor`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 775: Cultural Auto-Retry and Backoff Coordinator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 776: Cultural Failure Root-Cause Miner
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Failure Root-Cause Miner`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 777: Cultural Regression Sentinel
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Regression Sentinel`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 778: Cultural Memory Consolidation Pipeline
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Memory Consolidation Pipeline`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 779: Cultural Knowledge Graph Linker
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Knowledge Graph Linker`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 780: Cultural Semantic Retrieval Ranker
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Semantic Retrieval Ranker`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 781: Cultural Plan Quality Evaluator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Plan Quality Evaluator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 782: Cultural Multi-Agent Negotiation Mediator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 783: Cultural Conflict Resolution Coach
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Conflict Resolution Coach`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 784: Cultural Explainability Narrative Builder
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Explainability Narrative Builder`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 785: Cultural Uncertainty Communicator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Uncertainty Communicator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 786: Cultural Experiment Design Generator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Experiment Design Generator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 787: Cultural A/B Rollout Governor
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural A/B Rollout Governor`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 788: Cultural Incident Playbook Synthesizer
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Incident Playbook Synthesizer`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 789: Cultural Disaster Recovery Orchestrator
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 790: Cultural Privacy Preserving Data Broker
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Privacy Preserving Data Broker`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 791: Cultural Security Threat Modeler
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Security Threat Modeler`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 792: Cultural Compliance Evidence Mapper
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Compliance Evidence Mapper`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 793: Cultural Cost-Benefit Forecaster
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Cost-Benefit Forecaster`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 794: Cultural Equity Impact Scorer
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Equity Impact Scorer`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 795: Cultural Community Feedback Harvester
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Community Feedback Harvester`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 796: Cultural KPI Dashboard Publisher
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural KPI Dashboard Publisher`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 797: Cultural Skill Gap Diagnoser
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Skill Gap Diagnoser`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 798: Cultural Training Curriculum Composer
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Training Curriculum Composer`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 799: Cultural Self-Reflection Error Taxonomist
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 800: Cultural Continuous Improvement Planner
- Domain: Multilingual and Cultural Adaptation
- Why this new skill is needed: We need this skill because global utility requires language and cultural context fidelity. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Cultural Continuous Improvement Planner`, including at least three measurable KPIs tied to context mismatch and exclusion.
2. Design and version the input/output contract for language variants, cultural norms, and local preferences, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover context mismatch and exclusion, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 801: Inclusion Signal Ingestion Normalizer
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Signal Ingestion Normalizer`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 802: Inclusion Context Window Prioritizer
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Context Window Prioritizer`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 803: Inclusion Evidence Provenance Tracker
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Evidence Provenance Tracker`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 804: Inclusion Contradiction Detector
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Contradiction Detector`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 805: Inclusion Confidence Calibration Engine
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Confidence Calibration Engine`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 806: Inclusion Counterfactual Simulator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Counterfactual Simulator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 807: Inclusion Goal Decomposer
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Goal Decomposer`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 808: Inclusion Dependency DAG Planner
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Dependency DAG Planner`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 809: Inclusion Resource Budget Allocator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Resource Budget Allocator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 810: Inclusion Risk-Aware Scheduler
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Risk-Aware Scheduler`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 811: Inclusion Policy Constraint Compiler
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Policy Constraint Compiler`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 812: Inclusion Human Approval Router
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Human Approval Router`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 813: Inclusion Task Handoff Contractor
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Task Handoff Contractor`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 814: Inclusion Tool Health Monitor
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Tool Health Monitor`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 815: Inclusion Auto-Retry and Backoff Coordinator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 816: Inclusion Failure Root-Cause Miner
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Failure Root-Cause Miner`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 817: Inclusion Regression Sentinel
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Regression Sentinel`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 818: Inclusion Memory Consolidation Pipeline
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Memory Consolidation Pipeline`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 819: Inclusion Knowledge Graph Linker
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Knowledge Graph Linker`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 820: Inclusion Semantic Retrieval Ranker
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Semantic Retrieval Ranker`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 821: Inclusion Plan Quality Evaluator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Plan Quality Evaluator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 822: Inclusion Multi-Agent Negotiation Mediator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 823: Inclusion Conflict Resolution Coach
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Conflict Resolution Coach`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 824: Inclusion Explainability Narrative Builder
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Explainability Narrative Builder`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 825: Inclusion Uncertainty Communicator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Uncertainty Communicator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 826: Inclusion Experiment Design Generator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Experiment Design Generator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 827: Inclusion A/B Rollout Governor
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion A/B Rollout Governor`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 828: Inclusion Incident Playbook Synthesizer
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Incident Playbook Synthesizer`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 829: Inclusion Disaster Recovery Orchestrator
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 830: Inclusion Privacy Preserving Data Broker
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Privacy Preserving Data Broker`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 831: Inclusion Security Threat Modeler
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Security Threat Modeler`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 832: Inclusion Compliance Evidence Mapper
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Compliance Evidence Mapper`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 833: Inclusion Cost-Benefit Forecaster
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Cost-Benefit Forecaster`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 834: Inclusion Equity Impact Scorer
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Equity Impact Scorer`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 835: Inclusion Community Feedback Harvester
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Community Feedback Harvester`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 836: Inclusion KPI Dashboard Publisher
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion KPI Dashboard Publisher`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 837: Inclusion Skill Gap Diagnoser
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Skill Gap Diagnoser`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 838: Inclusion Training Curriculum Composer
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Training Curriculum Composer`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 839: Inclusion Self-Reflection Error Taxonomist
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 840: Inclusion Continuous Improvement Planner
- Domain: Accessibility and Inclusion
- Why this new skill is needed: We need this skill because systems must be operable and understandable for diverse users. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Inclusion Continuous Improvement Planner`, including at least three measurable KPIs tied to barriers for disabled and underserved groups.
2. Design and version the input/output contract for accessibility audits, accommodations, and usability feedback, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover barriers for disabled and underserved groups, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 841: Community Signal Ingestion Normalizer
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Signal Ingestion Normalizer`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 842: Community Context Window Prioritizer
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Context Window Prioritizer`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 843: Community Evidence Provenance Tracker
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Evidence Provenance Tracker`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 844: Community Contradiction Detector
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Contradiction Detector`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 845: Community Confidence Calibration Engine
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Confidence Calibration Engine`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 846: Community Counterfactual Simulator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Counterfactual Simulator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 847: Community Goal Decomposer
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Goal Decomposer`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 848: Community Dependency DAG Planner
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Dependency DAG Planner`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 849: Community Resource Budget Allocator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Resource Budget Allocator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 850: Community Risk-Aware Scheduler
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Risk-Aware Scheduler`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 851: Community Policy Constraint Compiler
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Policy Constraint Compiler`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 852: Community Human Approval Router
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Human Approval Router`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 853: Community Task Handoff Contractor
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Task Handoff Contractor`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 854: Community Tool Health Monitor
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Tool Health Monitor`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 855: Community Auto-Retry and Backoff Coordinator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 856: Community Failure Root-Cause Miner
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Failure Root-Cause Miner`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 857: Community Regression Sentinel
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Regression Sentinel`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 858: Community Memory Consolidation Pipeline
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Memory Consolidation Pipeline`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 859: Community Knowledge Graph Linker
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Knowledge Graph Linker`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 860: Community Semantic Retrieval Ranker
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Semantic Retrieval Ranker`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 861: Community Plan Quality Evaluator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Plan Quality Evaluator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 862: Community Multi-Agent Negotiation Mediator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 863: Community Conflict Resolution Coach
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Conflict Resolution Coach`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 864: Community Explainability Narrative Builder
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Explainability Narrative Builder`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 865: Community Uncertainty Communicator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Uncertainty Communicator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 866: Community Experiment Design Generator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Experiment Design Generator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 867: Community A/B Rollout Governor
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community A/B Rollout Governor`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 868: Community Incident Playbook Synthesizer
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Incident Playbook Synthesizer`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 869: Community Disaster Recovery Orchestrator
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 870: Community Privacy Preserving Data Broker
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Privacy Preserving Data Broker`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 871: Community Security Threat Modeler
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Security Threat Modeler`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 872: Community Compliance Evidence Mapper
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Compliance Evidence Mapper`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 873: Community Cost-Benefit Forecaster
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Cost-Benefit Forecaster`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 874: Community Equity Impact Scorer
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Equity Impact Scorer`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 875: Community Community Feedback Harvester
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Community Feedback Harvester`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 876: Community KPI Dashboard Publisher
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community KPI Dashboard Publisher`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 877: Community Skill Gap Diagnoser
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Skill Gap Diagnoser`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 878: Community Training Curriculum Composer
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Training Curriculum Composer`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 879: Community Self-Reflection Error Taxonomist
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 880: Community Continuous Improvement Planner
- Domain: Community Engagement and Feedback
- Why this new skill is needed: We need this skill because real-world feedback loops are necessary for continuous alignment. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Community Continuous Improvement Planner`, including at least three measurable KPIs tied to community trust loss and unaddressed concerns.
2. Design and version the input/output contract for feedback channels, sentiment, urgency, and follow-ups, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover community trust loss and unaddressed concerns, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 881: Rights Signal Ingestion Normalizer
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Signal Ingestion Normalizer`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 882: Rights Context Window Prioritizer
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Context Window Prioritizer`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 883: Rights Evidence Provenance Tracker
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Evidence Provenance Tracker`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 884: Rights Contradiction Detector
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Contradiction Detector`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 885: Rights Confidence Calibration Engine
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Confidence Calibration Engine`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 886: Rights Counterfactual Simulator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Counterfactual Simulator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 887: Rights Goal Decomposer
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Goal Decomposer`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 888: Rights Dependency DAG Planner
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Dependency DAG Planner`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 889: Rights Resource Budget Allocator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Resource Budget Allocator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 890: Rights Risk-Aware Scheduler
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Risk-Aware Scheduler`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 891: Rights Policy Constraint Compiler
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Policy Constraint Compiler`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 892: Rights Human Approval Router
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Human Approval Router`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 893: Rights Task Handoff Contractor
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Task Handoff Contractor`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 894: Rights Tool Health Monitor
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Tool Health Monitor`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 895: Rights Auto-Retry and Backoff Coordinator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 896: Rights Failure Root-Cause Miner
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Failure Root-Cause Miner`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 897: Rights Regression Sentinel
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Regression Sentinel`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 898: Rights Memory Consolidation Pipeline
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Memory Consolidation Pipeline`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 899: Rights Knowledge Graph Linker
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Knowledge Graph Linker`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 900: Rights Semantic Retrieval Ranker
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Semantic Retrieval Ranker`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 901: Rights Plan Quality Evaluator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Plan Quality Evaluator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 902: Rights Multi-Agent Negotiation Mediator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 903: Rights Conflict Resolution Coach
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Conflict Resolution Coach`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 904: Rights Explainability Narrative Builder
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Explainability Narrative Builder`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 905: Rights Uncertainty Communicator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Uncertainty Communicator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 906: Rights Experiment Design Generator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Experiment Design Generator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 907: Rights A/B Rollout Governor
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights A/B Rollout Governor`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 908: Rights Incident Playbook Synthesizer
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Incident Playbook Synthesizer`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 909: Rights Disaster Recovery Orchestrator
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 910: Rights Privacy Preserving Data Broker
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Privacy Preserving Data Broker`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 911: Rights Security Threat Modeler
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Security Threat Modeler`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 912: Rights Compliance Evidence Mapper
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Compliance Evidence Mapper`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 913: Rights Cost-Benefit Forecaster
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Cost-Benefit Forecaster`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 914: Rights Equity Impact Scorer
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Equity Impact Scorer`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 915: Rights Community Feedback Harvester
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Community Feedback Harvester`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 916: Rights KPI Dashboard Publisher
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights KPI Dashboard Publisher`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 917: Rights Skill Gap Diagnoser
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Skill Gap Diagnoser`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 918: Rights Training Curriculum Composer
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Training Curriculum Composer`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 919: Rights Self-Reflection Error Taxonomist
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 920: Rights Continuous Improvement Planner
- Domain: Legal, Rights, and Compliance
- Why this new skill is needed: We need this skill because operations must preserve rights and satisfy jurisdictional obligations. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Rights Continuous Improvement Planner`, including at least three measurable KPIs tied to rights violations and compliance penalties.
2. Design and version the input/output contract for requirements mappings, legal decisions, and evidence trails, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover rights violations and compliance penalties, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 921: Infra Signal Ingestion Normalizer
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Signal Ingestion Normalizer`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 922: Infra Context Window Prioritizer
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Context Window Prioritizer`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 923: Infra Evidence Provenance Tracker
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Evidence Provenance Tracker`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 924: Infra Contradiction Detector
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Contradiction Detector`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 925: Infra Confidence Calibration Engine
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Confidence Calibration Engine`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 926: Infra Counterfactual Simulator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Counterfactual Simulator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 927: Infra Goal Decomposer
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Goal Decomposer`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 928: Infra Dependency DAG Planner
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Dependency DAG Planner`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 929: Infra Resource Budget Allocator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Resource Budget Allocator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 930: Infra Risk-Aware Scheduler
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Risk-Aware Scheduler`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 931: Infra Policy Constraint Compiler
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Policy Constraint Compiler`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 932: Infra Human Approval Router
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Human Approval Router`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 933: Infra Task Handoff Contractor
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Task Handoff Contractor`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 934: Infra Tool Health Monitor
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Tool Health Monitor`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 935: Infra Auto-Retry and Backoff Coordinator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 936: Infra Failure Root-Cause Miner
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Failure Root-Cause Miner`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 937: Infra Regression Sentinel
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Regression Sentinel`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 938: Infra Memory Consolidation Pipeline
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Memory Consolidation Pipeline`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 939: Infra Knowledge Graph Linker
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Knowledge Graph Linker`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 940: Infra Semantic Retrieval Ranker
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Semantic Retrieval Ranker`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 941: Infra Plan Quality Evaluator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Plan Quality Evaluator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 942: Infra Multi-Agent Negotiation Mediator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 943: Infra Conflict Resolution Coach
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Conflict Resolution Coach`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 944: Infra Explainability Narrative Builder
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Explainability Narrative Builder`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 945: Infra Uncertainty Communicator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Uncertainty Communicator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 946: Infra Experiment Design Generator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Experiment Design Generator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 947: Infra A/B Rollout Governor
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra A/B Rollout Governor`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 948: Infra Incident Playbook Synthesizer
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Incident Playbook Synthesizer`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 949: Infra Disaster Recovery Orchestrator
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 950: Infra Privacy Preserving Data Broker
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Privacy Preserving Data Broker`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 951: Infra Security Threat Modeler
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Security Threat Modeler`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 952: Infra Compliance Evidence Mapper
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Compliance Evidence Mapper`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 953: Infra Cost-Benefit Forecaster
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Cost-Benefit Forecaster`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 954: Infra Equity Impact Scorer
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Equity Impact Scorer`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 955: Infra Community Feedback Harvester
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Community Feedback Harvester`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 956: Infra KPI Dashboard Publisher
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra KPI Dashboard Publisher`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 957: Infra Skill Gap Diagnoser
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Skill Gap Diagnoser`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 958: Infra Training Curriculum Composer
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Training Curriculum Composer`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 959: Infra Self-Reflection Error Taxonomist
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 960: Infra Continuous Improvement Planner
- Domain: Infrastructure and Sustainability
- Why this new skill is needed: We need this skill because long-term scale depends on resilient and sustainable infrastructure choices. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Infra Continuous Improvement Planner`, including at least three measurable KPIs tied to capacity collapse and environmental debt.
2. Design and version the input/output contract for capacity forecasts, energy usage, and sustainability metrics, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capacity collapse and environmental debt, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 961: Evolution Signal Ingestion Normalizer
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill stabilizes noisy upstream inputs before they contaminate planning.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Signal Ingestion Normalizer`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using schema mapping and validation, and produce normalized signal feeds with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 962: Evolution Context Window Prioritizer
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill surfaces the most decision-relevant context under tight token budgets.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Context Window Prioritizer`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using importance scoring, and produce ranked context bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 963: Evolution Evidence Provenance Tracker
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill preserves source lineage so claims remain auditable.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Evidence Provenance Tracker`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using signed provenance links, and produce evidence lineage graphs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 964: Evolution Contradiction Detector
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill catches internal and external claim conflicts early.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Contradiction Detector`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using cross-claim consistency checks, and produce contradiction alerts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 965: Evolution Confidence Calibration Engine
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill aligns reported confidence with actual uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Confidence Calibration Engine`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using calibration curves and error bins, and produce calibrated confidence scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 966: Evolution Counterfactual Simulator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill tests alternatives before costly commitments.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Counterfactual Simulator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using counterfactual replay, and produce scenario comparison reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 967: Evolution Goal Decomposer
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill breaks ambiguous missions into executable units.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Goal Decomposer`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using hierarchical decomposition, and produce atomic task trees with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 968: Evolution Dependency DAG Planner
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill prevents sequencing errors and hidden blockers.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Dependency DAG Planner`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using dependency graph compilation, and produce validated workflow DAGs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 969: Evolution Resource Budget Allocator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill matches mission ambition to finite execution capacity.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Resource Budget Allocator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using capacity-aware allocation, and produce budgeted execution plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 970: Evolution Risk-Aware Scheduler
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill times execution based on risk posture instead of urgency alone.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Risk-Aware Scheduler`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using risk-weighted sequencing, and produce risk-gated schedules with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 971: Evolution Policy Constraint Compiler
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill turns governance language into enforceable runtime checks.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Policy Constraint Compiler`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using rule compilation, and produce executable policy bundles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 972: Evolution Human Approval Router
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill directs high-risk decisions to the right humans quickly.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Human Approval Router`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using reviewer routing policies, and produce priority approval queues with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 973: Evolution Task Handoff Contractor
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill standardizes handoffs between agents and humans.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Task Handoff Contractor`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using contracted payload schemas, and produce typed handoff artifacts with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 974: Evolution Tool Health Monitor
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill detects tool flakiness before it impacts mission outcomes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Tool Health Monitor`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using telemetry aggregation and SLO checks, and produce tool reliability scores with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 975: Evolution Auto-Retry and Backoff Coordinator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill improves success rates while preventing retry storms.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Auto-Retry and Backoff Coordinator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using adaptive backoff control, and produce retry policy decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 976: Evolution Failure Root-Cause Miner
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill finds recurring break patterns to speed remediation.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Failure Root-Cause Miner`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using error pattern mining, and produce root-cause clusters with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 977: Evolution Regression Sentinel
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill prevents unnoticed quality drift after updates.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Regression Sentinel`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using baseline-delta detection, and produce regression watchlists with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 978: Evolution Memory Consolidation Pipeline
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill turns raw logs into durable reusable memory.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Memory Consolidation Pipeline`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using episodic-to-semantic consolidation, and produce consolidated memory snapshots with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 979: Evolution Knowledge Graph Linker
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill connects fragmented facts into reusable structures.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Knowledge Graph Linker`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using entity and relation linking, and produce linked knowledge entities with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 980: Evolution Semantic Retrieval Ranker
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill improves recall precision for downstream decision quality.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Semantic Retrieval Ranker`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using semantic relevance scoring, and produce ranked retrieval results with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 981: Evolution Plan Quality Evaluator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill quantifies whether plans are complete, safe, and feasible.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Plan Quality Evaluator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using multi-criteria plan scoring, and produce plan quality scorecards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 982: Evolution Multi-Agent Negotiation Mediator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill resolves resource and strategy conflicts with explicit tradeoffs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Multi-Agent Negotiation Mediator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using structured bargaining protocols, and produce negotiated agreement sets with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 983: Evolution Conflict Resolution Coach
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill reduces deadlocks in human-agent collaboration loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Conflict Resolution Coach`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using guided mediation prompts, and produce conflict remediation playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 984: Evolution Explainability Narrative Builder
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill translates technical decisions into operator-usable narratives.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Explainability Narrative Builder`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using reason synthesis and abstraction, and produce decision narratives with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 985: Evolution Uncertainty Communicator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill prevents overstatement by explicitly framing uncertainty.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Uncertainty Communicator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using confidence-bound communication templates, and produce uncertainty briefs with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 986: Evolution Experiment Design Generator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill converts unknowns into testable learning loops.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Experiment Design Generator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using hypothesis-driven design, and produce experiment plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 987: Evolution A/B Rollout Governor
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill controls production risk during behavioral changes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution A/B Rollout Governor`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using staged rollout policies, and produce safe rollout decisions with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 988: Evolution Incident Playbook Synthesizer
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill creates repeatable response procedures from incident history.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Incident Playbook Synthesizer`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using pattern-to-playbook synthesis, and produce incident playbooks with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 989: Evolution Disaster Recovery Orchestrator
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill improves recovery speed after severe outages.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Disaster Recovery Orchestrator`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using failover and restoration sequencing, and produce recovery mission plans with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 990: Evolution Privacy Preserving Data Broker
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill enables collaboration while minimizing raw data exposure.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Privacy Preserving Data Broker`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using policy-scoped data mediation, and produce privacy-scoped exchanges with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 991: Evolution Security Threat Modeler
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill anticipates attack paths before adversaries exploit them.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Security Threat Modeler`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using attack-surface modeling, and produce threat models with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 992: Evolution Compliance Evidence Mapper
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill keeps proof of control coverage continuously current.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Compliance Evidence Mapper`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using requirement-to-evidence mapping, and produce compliance evidence matrices with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 993: Evolution Cost-Benefit Forecaster
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill prioritizes actions with the strongest net value.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Cost-Benefit Forecaster`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using cost-impact simulation, and produce forecasted ROI scenarios with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 994: Evolution Equity Impact Scorer
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill exposes uneven benefit/harm distribution before rollout.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Equity Impact Scorer`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using group-level impact scoring, and produce equity impact profiles with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 995: Evolution Community Feedback Harvester
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill integrates lived user feedback into planning cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Community Feedback Harvester`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using feedback normalization and clustering, and produce theme-prioritized feedback digests with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 996: Evolution KPI Dashboard Publisher
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill keeps mission status observable in real time.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution KPI Dashboard Publisher`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using metric synthesis and publication, and produce operator KPI dashboards with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 997: Evolution Skill Gap Diagnoser
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill identifies where agents and humans need capability upgrades.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Skill Gap Diagnoser`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using competency coverage analysis, and produce skill gap reports with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 998: Evolution Training Curriculum Composer
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill converts capability gaps into actionable upskilling programs.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Training Curriculum Composer`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using sequenced learning path design, and produce role-specific curricula with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 999: Evolution Self-Reflection Error Taxonomist
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill classifies recurrent reasoning failures for targeted fixes.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Self-Reflection Error Taxonomist`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using failure-type clustering, and produce error taxonomies with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.

## Update 1000: Evolution Continuous Improvement Planner
- Domain: Autonomous Learning and Evolution
- Why this new skill is needed: We need this skill because agents stagnate without structured reflection and continuous improvement loops. This specific skill turns findings into sustained upgrade cycles.
- Step-by-step implementation guide:
1. Define the scope and success metrics for `Evolution Continuous Improvement Planner`, including at least three measurable KPIs tied to capability stagnation and repeated blind spots.
2. Design and version the input/output contract for outcomes, error taxonomies, and adaptation decisions, then add schema validation and failure-mode handling.
3. Implement the core capability using closed-loop prioritization, and produce improvement roadmaps with deterministic scoring.
4. Integrate the skill into swarm orchestration: task routing, approval gates, retry strategy, and rollback controls.
5. Add unit, integration, and simulation tests that explicitly cover capability stagnation and repeated blind spots, then run regression baselines.
6. Deploy behind a feature flag, monitor telemetry/alerts for two release cycles, and iterate thresholds based on observed outcomes.
